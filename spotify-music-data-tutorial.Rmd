---
title: "Data Wrangling Tutorial"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse) # Automatically loads ggplot2 and dplyr
knitr::opts_chunk$set(echo = FALSE)
spotify_songs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')
```


## Intro to Data Wrangling

### Wrangling Spotify Music Data

Tutorial intro: Insert description of data wrangling and dataset

### Check out the dataset!

Run this code to view the data on spotify songs!

```{r view-data, exercise=TRUE, exercise.eval=TRUE}
spotify_songs
```


## Richney's Part

##Question: Most popular tracks?

How can we use data wrangling to find the most popular track on the list? Well first we'll need to learn a few functions in R that will help us out.

The first function we will learn is: select()
select() takes a subset of coulmns that you choose and will display them. So instaead of having to look at all of the columns in this dataset, we can narrow it down to the ones we want to see. Let's try it out!

First, to see which track is the most popular, we will need to look at these columns: "track_name" and "track_popularity"
```{r}
popular_track = spotify_songs %>% 
  select(track_name, track_popularity)

View(popular_track)
```


Wow, that really makes things  much easier to look at. However, it looks like some of the track names repeat? No worries, theres a way to fix that. We can get rid of duplicate rows with the distinctt() function!
```{r}
popular_tracks = popular_track %>% distinct()
View(popular_tracks)
```

Now how do we look at the 10 most popular tracks? we use the top_n() function!
```{r}
top_10 = popular_tracks %>% top_n(10)
view(top_10)
```

Uh oh, somethings a bit off...i think we need to arrange() the data into descending order:
```{r}
top_10 %>% arrange(desc(track_popularity))
```

##Question: Most popular albums?

Now let's try to answer this next question with the skills we learned so far and with some new tricks!
First, lets select the coulmns we want to view.
```{r}
popular_albums = spotify_songs %>% 
  select(track_album_name, track_name, track_popularity)
View(popular_albums)
```

Introducing summarize() and groupby()
```{r}
#using summarize and group_by
popular_albums %>% 
  group_by(track_album_name) %>% 
  summarize(track_name = n()) %>% 
  arrange(desc(track_name))
```

Using a simplified version with count():
```{r}
#using count
popular_albums %>% 
  count(track_album_name, sort = TRUE)
```

Summarize mean ratings per album:
```{r}
popular_albums %>%
  group_by(track_album_name) %>% 
  summarize(track_name = n(),
            mean_pop = mean(track_popularity, na.rm = TRUE)) %>% 
  arrange(desc(mean_pop))
```

lumping factors together for a graph:
```{r}

```



## Kaya's Part: summarize() and groupby()

summarize() and group_by() allow us to make calculations and comparisons.

summarize() (with or without group_by()) collapses the data into rows based on summary statistics.

The important step in summarize() is specifying how we want to reduce the data to a single set of summary statistics.

Examples: mean(), sd(), median(), IQR(), max(), n(), and many more

Using the spotify_songs data frame, let's calculate the mean danceability (danceability) of all songs:

```{r mean_danceability, exercise=TRUE}
spotify_songs %>%
  summarize(mean_danceability = mean(danceability, na.rm = TRUE))
```

Note: We added na.rm = TRUE to remove NA (missing values) from each calculation.

Otherwise, the output for mean() and sd() would also be NA.


### Average Danceability per Playlist Genre

We just used summarize() to calculate the mean duration of all songs.

But what if we want to calculate these summary statistics for each genre?

We can use group_by() in the pipeline to generate aggregate summary statistics!

Run the R code below to view the mean danceability of each playlist_genre using `groupby()`:

```{r avg_genre_danceability, exercise=TRUE}
avg_genre_danceability = spotify_songs %>%
  select(playlist_genre, danceability) %>% 
  group_by(playlist_genre) %>% 
  summarize(mean_danceability = mean(danceability, na.rm = TRUE)) %>%
  arrange(mean_danceability)

avg_genre_danceability
```

We added the step group_by(playlist_genre), which does exactly what it sounds like: it groups by playlist_genre before calculating summary statistics.

Note: We never use the group_by() operation by itself. We always combine it with a function that performs a calculation, such as summarize().

### Exercise: Average Energy per Playlist Subgenre

Using the spotify_songs data frame, calculate the `mean` energy level `energy` of each `playlist_subgenre`. Assign the pipeline to the name `avg_subgenre_energy`.


```{r avg_subgenre_energy, exercise=TRUE, exercise.lines = 7}

```

---
correct answer:
avg_subgenre_energy = spotify_songs %>%
  select(playlist_subgenre, energy) %>% 
  group_by(playlist_subgenre) %>% 
  summarize(mean_energy = mean(energy, na.rm = TRUE)) %>%
  arrange(mean_energy)

avg_subgenre_energy
---

### Quiz

Now, using what you learned in the previous exercise, select the least energetic subgenre!


```{r quiz}
quiz(
  question("Which subgenre has the least energy?",
    answer("pop"),
    answer("permanent wave"),
    answer("neo soul", correct = TRUE),
    answer("tropical")
  )
)
```


