---
title: "Data Wrangling Tutorial"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse) # Automatically loads ggplot2 and dplyr
knitr::opts_chunk$set(echo = FALSE)
spotify_songs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')
```


## Intro to Data Wrangling

Tutorial intro: Insert description of data wrangling and dataset


## Topic 1

### Check out the dataset!

Run this code to view the data on spotify songs!

```{r view-data, exercise=TRUE, exercise.eval=TRUE}
View(spotify_songs)
```

### Exercise 

Write the R code required to groupby() playlist_genre:

```{r group-by, exercise=TRUE}
spotify_songs %>%
  select(playlist_genre, danceability) %>%
  group_by(playlist_genre)
```

### Exercise with Code

*Here's an exercise with some prepopulated code as well as `exercise.lines = 5` to provide a bit more initial room to work.*

Now write a function that adds any two numbers and then call it:

```{r add-function, exercise=TRUE, exercise.lines = 5}
add <- function() {
  
}
```

## Topic 2

### Exercise with Hint

*Here's an exercise where the chunk is pre-evaulated via the `exercise.eval` option (so the user can see the default output we'd like them to customize). We also add a "hint" to the correct solution via the chunk immediate below labeled `print-limit-hint`.*

Modify the following code to limit the number of rows printed to 5:

```{r print-limit, exercise=TRUE, exercise.eval=TRUE}
mtcars
```

```{r print-limit-hint}
head(mtcars)
```

### Quiz

*You can include any number of single or multiple choice questions as a quiz. Use the `question` function to define a question and the `quiz` function for grouping multiple questions together.*

Some questions to verify that you understand the purposes of various base and recommended R packages:

```{r quiz}
quiz(
  question("Which package contains functions for installing other R packages?",
    answer("base"),
    answer("tools"),
    answer("utils", correct = TRUE),
    answer("codetools")
  ),
  question("Which of the R packages listed below are used to create plots?",
    answer("lattice", correct = TRUE),
    answer("tools"),
    answer("stats"),
    answer("grid", correct = TRUE)
  )
)
```

##Question: Most popular tracks?

How can we use data wrangling to find the most popular track on the list? Well first we'll need to learn a few functions in R that will help us out.

The first function we will learn is: select()
select() takes a subset of coulmns that you choose and will display them. So instaead of having to look at all of the columns in this dataset, we can narrow it down to the ones we want to see. Let's try it out!

First, to see which track is the most popular, we will need to look at these columns: "track_name" and "track_popularity"
```{r}
popular_track = spotify_songs %>% 
  select(track_name, track_popularity)

View(popular_track)
```


Wow, that really makes things  much easier to look at. However, it looks like some of the track names repeat? No worries, theres a way to fix that. We can get rid of duplicate rows with the distinctt() function!
```{r}
popular_tracks = popular_track %>% distinct()
View(popular_tracks)
```

Now how do we look at the 10 most popular tracks? we use the top_n() function!
```{r}
top_10 = popular_tracks %>% top_n(10)
view(top_10)
```

Uh oh, somethings a bit off...i think we need to arrange() the data into descending order:
```{r}
top_10 %>% arrange(desc(track_popularity))
```

##Question: Most popular albums?

Now let's try to answer this next question with the skills we learned so far and with some new tricks!
First, lets select the coulmns we want to view.
```{r}
popular_albums = spotify_songs %>% 
  select(track_album_name, track_name, track_popularity)
View(popular_albums)
```

Introducing summarize() and groupby()
```{r}
#using summarize and group_by
popular_albums %>% 
  group_by(track_album_name) %>% 
  summarize(track_name = n()) %>% 
  arrange(desc(track_name))
```

Using a simplified version with count():
```{r}
#using count
popular_albums %>% 
  count(track_album_name, sort = TRUE)
```

Summarize mean ratings per album:
```{r}
popular_albums %>%
  group_by(track_album_name) %>% 
  summarize(track_name = n(),
            mean_pop = mean(track_popularity, na.rm = TRUE)) %>% 
  arrange(desc(mean_pop))
```

lumping factors together for a graph:
```{r}

```



