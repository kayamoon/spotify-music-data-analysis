---
title: "Data Wrangling Tutorial"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse) # Automatically loads ggplot2 and dplyr
knitr::opts_chunk$set(echo = FALSE)
spotify_songs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-21/spotify_songs.csv')
```


## Intro to Data Wrangling

### Wrangling Spotify Music Data

Tutorial intro: Insert description of data wrangling and dataset

### Check out the dataset!

Run this code to view the data on spotify songs!

```{r view-data, exercise=TRUE, exercise.eval=TRUE}
spotify_songs
```

## Question: Most popular tracks?

How can we use data wrangling to find the most popular tracks on the list? Well first we'll need to learn a few functions in R that will help us out.

### Introducing select(), distinct(), top_n(), and arrange()
The first function we will learn is: select().

#### select()
Select() takes a subset of coulmns that you choose and will display them. So instaead of having to look at all of the columns in this
dataset, we can narrow it down to the ones we want to see. Let's try it out!

First, to see which track is the most popular, we will need to look at these columns: "track_name" and "track_popularity"
```{r}
popular_track = spotify_songs %>% 
  select(track_name, track_popularity)

popular_track
```


Wow, that really makes things  much easier to look at. However, it looks like some of the track names repeat? No worries, theres a way to
fix that. We can get rid of duplicate rows with the distinct() function!

#### distinct()

The distinct() function can be used to keep only unique/distinct rows from a data frame. If there are duplicate rows, only the first row
is preserved.
```{r}
popular_tracks = popular_track %>% distinct()
popular_tracks
```

#### top_n()

Now how do we look at the 10 most popular tracks? we use the top_n() function!
```{r}
top_10 = popular_tracks %>% top_n(10)
top_10
```

#### arrange()

Uh oh, somethings a bit off...I think we need to arrange() the data into descending order:
```{r}
top_10 %>% arrange(desc(track_popularity))
```

## Question: Most popular albums?

Now let's try to answer this next question with the skills we learned so far and with some new tricks!

First, lets select the columns we want to view: "track_album_name" , "track_popularity"
```{r}
spotify_songs %>% 
  select(track_album_name, track_popularity)
```

### Introducing summarize() and groupby()

summarize() and group_by() allow us to make calculations and comparisons.

summarize() (with or without group_by()) collapses the data into rows based on summary statistics.

The important step in summarize() is specifying how we want to reduce the data to a single set of summary statistics.

Examples: mean(), sd(), median(), IQR(), max(), n(), and many more.

Now let's try out the summarize() function to find the mean popularity of all the songs in the dataframe:
```{r}
#summarize on its own as an example
spotify_songs %>%
  summarize(mean_pop = mean(track_popularity, na.rm = TRUE))
```

Note: We added na.rm = TRUE to remove NA (missing values) from each calculation.

Otherwise, the output for mean() and sd() would also be NA.

#### Using summarize() with group_by().

We just used summarize() to calculate the mean duration of all songs.

But what if we want to calculate these summary statistics for each genre?

We can use group_by() in the pipeline to generate aggregate summary statistics!

The summarize() function is almost always used in conjunction with group_by().

Run the R code below to view the mean popularity of songs per album with `groupby()`:
```{r}
#using summarize and group_by
spotify_songs %>% 
  group_by(track_album_name) %>% 
  summarize(track_name = n()) %>% 
  arrange(desc(track_name))
```

Note: We never use the group_by() operation by itself. We always combine it with a function that performs a calculation, such as summarize().


Now that we have learned how to use summarize and group_by, let's try to answer our question of: what are the most popular albums? How?

We're gonna use the spotify_songs data frame,and mean ratings per album!

Summarize mean ratings per album:
```{r}
popular_albums = spotify_songs %>%
  group_by(track_album_name) %>% 
  summarize(track_name = n(),
            mean_pop = mean(track_popularity, na.rm = TRUE)) %>% 
  arrange(desc(mean_pop))

popular_albums
```

NOw let's see the top 5 popular albums using top_n():

```{r}
top_albums = popular_albums %>% 
  top_n(5)

top_albums
```

Let's see how this would look as a graphic visual:
```{r}
top_albums %>% 
  ggplot(aes(x = track_album_name, y = mean_pop)) +
  geom_col() +
  coord_flip() +
  labs(title = "5 Most Popular albums on Spotify", x = "Album Name", y ="Average Rating")
```

## Kaya's Part: summarize() and groupby()

summarize() and group_by() allow us to make calculations and comparisons.

summarize() (with or without group_by()) collapses the data into rows based on summary statistics.

The important step in summarize() is specifying how we want to reduce the data to a single set of summary statistics.

Examples: mean(), sd(), median(), IQR(), max(), n(), and many more

Using the spotify_songs data frame, let's calculate the mean danceability for all of the songs:

```{r mean_danceability, exercise=TRUE}
spotify_songs %>%
  summarize(mean_danceability = mean(danceability, na.rm = TRUE))
```

Note: We added na.rm = TRUE to remove NA (missing values) from each calculation.

Otherwise, the output for mean() and sd() would also be NA.


### Average Danceability per Playlist Genre

We just used summarize() to calculate the mean duration of all songs.

But what if we want to calculate these summary statistics for each genre?

We can use group_by() in the pipeline to generate aggregate summary statistics!

Run the R code below to view the mean danceability of each playlist_genre using `groupby()`:

```{r avg_genre_danceability, exercise=TRUE}
avg_genre_danceability = spotify_songs %>%
  select(playlist_genre, danceability) %>% 
  group_by(playlist_genre) %>% 
  summarize(mean_danceability = mean(danceability, na.rm = TRUE)) %>%
  arrange(mean_danceability)

avg_genre_danceability
```

We added the step group_by(playlist_genre), which does exactly what it sounds like: it groups by playlist_genre before calculating summary statistics.

Note: We never use the group_by() operation by itself. We always combine it with a function that performs a calculation, such as summarize().

### Exercise: Average Energy per Playlist Subgenre

Using the spotify_songs data frame, calculate the `mean` energy level `energy` of each `playlist_subgenre`. Assign the pipeline to the name `avg_subgenre_energy`.


```{r avg_subgenre_energy, exercise=TRUE, exercise.lines = 7}

```

---
correct answer:
avg_subgenre_energy = spotify_songs %>%
  select(playlist_subgenre, energy) %>% 
  group_by(playlist_subgenre) %>% 
  summarize(mean_energy = mean(energy, na.rm = TRUE)) %>%
  arrange(mean_energy)

avg_subgenre_energy
---

### Quiz

Now, using what you learned in the previous exercise, select the least energetic subgenre!


```{r quiz}
quiz(
  question("Which subgenre has the least energy?",
    answer("pop"),
    answer("permanent wave"),
    answer("neo soul", correct = TRUE),
    answer("tropical")
  )
)
```


